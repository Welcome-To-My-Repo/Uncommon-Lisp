The Uncommon Lisp Language Standard  -------------------------------------------
June 2020
(C)opyright Daniel (Robin) Smith

Introduction -------------------------------------------------------------------

This standard describes the qualities of a modern dynamic Lisp programming 
language, "Uncommon Lisp", and the dynamic language environment used to 
create programs in this language. UcL and its environment are presented as a
standard because there can exist many different approaches to achieving the 
qualities and behavior described in this document. Therefore, any manifestation
of the UcL language and environment must conform to the descriptions in this
document.

UcL is described using plain english. Like all Lisp languages, UcL is capable of
self-description, but for the sake of clarity, UcL is described in external
concepts.

Using this Document ------------------------------------------------------------

This document is comprised of sections denoted by the name of the section 
followed by dashes to make them stand out. Each section will cover a specific
aspect of the UcL language and environment. Sections may also include
descriptions of core syntax and functions in UcL. Core syntax and functions are
required to be present in all implementations of UcL.

Function Notation --------------------------------------------------------------

UcL Functions are bounded by a closed set of parentheses.
Each part of the function is separated by a space.
The first element inside the parentheses is always the function identifier.
The following elements are acceptable parameters to the function.
An explanation of the function's purpose follows the closing parenthesis.

Design Philosophy --------------------------------------------------------------

Umcommon Lisp, or "UcL", is a Lisp language with a modern design. Many of the 
features that made Lisp famous were designed in the past for a drastically
different environment. UcL reimagines these famous qualities in a way that's 
comdusive to modern programming. Uncommon Lisp can be considered a consolidation
of the philosophies presented by modern Lisp languages like Common Lisp, 
Clojure, and Scheme.

Uncommon Lisp has only a few design principals:
1. Prioritize emergent syntax.
2. Be reasonably compact
3. Allow future-proofing

Emergent syntax means that there should be many ways to implement an algorithm,
using the same base set of operations. Take mathematical operations for example.
There are five basic symbols that can be combined in any order to achieve a
specific algorithm. It's easier to add three addends using two additions than to
invent a new symbol specifically for adding three numbers. In that same sense, 
Uncommon Lisp shall not implement an abstract operation as a component of the 
language unless it cannot be represented with already existing syntax. This 
avoids the redundancy that often occurs in Common Lisp syntax.

Parallel to the first principal, Uncommon Lisp will be a small language. This is
not the same sense of small as Scheme, where any usefulness to the language must
be hand implemented by the users. This is why the term "compact" is used instead
of "small". Scheme is small and it lacks so many basic features that it's 
impossible to use except when implementing a higer level, more feature-full
language. Uncommon Lisp is full-featured without having an overwhelming amount 
of syntax.

The third principal is likely the most important. Lisp as a language is not
future proof. It was designed when general purpose hardware wasn't a concept, 
and died when the PC was popularized. Modern Lisp languages have no access to 
the underlying system because they were left behind when C became the system
language of choice. Uncommon Lisp implements two measures to avoid obsoletion,
it implements a means of interacting with native system libraries, and it
allows extension to implement access to any future manner of resource without
breaking the syntax.

Language Overview --------------------------------------------------------------

UcL is a multi-paradigm dynamic language with object orientation and a weak type
system with dynamic typing. UcL syntax uses traditional Lisp parenthesized 
prefix notation to represent operations. UcL can be statically compiled, but
like Lisp, it contains many reflective features suited for use in a dynamic 
environment.

Data ---------------------------------------------------------------------------

Natural information types are the underlying data types that support the UcL 
object typing system. Natural information exists as numbers, byte strings, or 
instructions. These three natural types are how information is introduced into
the language environment by the programmer. They are static and immutable.

Information stored in a program will always be one of these three natural types.
The object type system in UcL is derived from methods for access and handling of
these three static types. This avoids ambiguity that can interfere with other 
type systems. While UcL's object type system is weak, it can be said that the
language is still strongly typed due to the three static natural types that 
control the internal representation of data in a program.

Numbers ------------------------------------------------------------------------

Numbers can be any rational value. They can be described using decimal or 
scientific notation. UcL additionally supports the numerical bases 2, 10, 16 
and 256. Numbers are represented by the ASCII characters 0-9 and for hexadecimal
values, A-F as well. A radix point is represented by the dot character, ".". A 
single numerical place for bases 2, 10, and 16 is represented by a single 
character. For base 256, a single place is represented by a pair of hexadecimal
symbols and is end-bounded by a comma, "," unless a radix point is present. 

Positive and negative values are denoted using a sign prefix which is either a
plus or minus character, "+" "-" respectively. If a sign prefix is not present,
the represented numerical value is assumed to be positive.

To avoid ambiguity between data and identifiers, all numbers must be prefixed 
with the pound sign, "#".

Decimal Notation ---------------------------------------------------------------

In UcL, decimal notation is represented by an optional sign prefix, followed by
a number of numeric places followed by an optional radix point, ".", followed by
an optional number of numeric places. Each numeric place value is represented by
numerals 0-9 for bases 2 and 10 and 0-F for bases 16 and 256. 

In base two, only ones and zeros are accepted.
In a base 10 number, only 0-9 is accepted. 
In a hexadecimal number, only 0-F is accepted. 
In a base 256 number, only 0-F are accepted. 

Decimal notation without a sign prefix is assumed to represent a positive
number.

Below are some examples of decimal notation in UcL.
#-7
#4.5
#10010
#+4FC
#-7F,5F.3A,1D

Scientific Notation ------------------------------------------------------------

In UcL, scientific notation is represented by an optional sign prefix, followed 
by a numerical place, followed by a radix point, followed by a number of 
numerical places, followed by an exponent symbol, "^", followed by an optional 
sign prefix, followed by a number of numerical places. The places after the 
exponent symbol represent a power of the base number of the numerical base of 
the first number.

Below are some examples of Scientific Notation in UcL.

#+3.05^4
#-100101^11101
#FF^-A4
#74,FF^1A,04

Determining Numerical Representations ------------------------------------------

The type of numerical representation is determined in the following way. 
If a number does not have an exponent symbol "^", then it uses decimal notation, 
otherwise it uses scientific notation. 
If a number contains a radix point, it represents a rational value. 
If a number contains a comma, it represents a base 256 value.
If a number contains alphabetical characters, it represents a hexadecimal value.
If a number contains only numerical characters, it represents a decimal value.
If a number contains only the "1" and "0" characters, it represents a binary
value.
If a number begins with a "+" or "_" character, it is signed positive or 
negative. 
If an exponent symbol is followed directly by a "+" or "-" character, the 
exponential power is signed positive or negative.

Byte Strings -------------------------------------------------------------------

A byte string consists of a contiguous series of single byte values. Byte
strings can represent both raw data and ASCII, A byte string is represented by
an ASCII character string, or hexadecimal values.

A character string is represented by ASCII characters surrounded by double or 
single quotes. Double or single quotations have the same meaning, but if a 
string contains a single quote character, it must be surrounded by double quotes
and single quotes if a double quote character is used in the string.

A byte string is represented using two digit hexadecimal values surrounded by
pipe symbols, "|". Because each byte is represented by a hexadecimal pair, a
byte string must always contain an even number of characters.

Control characters and invisible characters are represented by an underscore
prefix, followed by a single character neumonic. Below is a list of 
abbreviations for different ascii values. 

a - bell
b - backspace
t - horizontal tab
l - line feed (new line)
v - vertical tab
f - form feed
r - carriage return
x - delete

c - End Of Text (^C)
d - End Of Transmission (EOF) (^D)
n - NULL (ASCII 0)
e - escape (ESC)

Constructing Byte Strings ------------------------------------------------------

Byte strings can be constructed using arbitrary combinations of the syntax
above. Strings of bytes, characters, and control characters can be combined to
represent a single contiguous byte string. Multiple strings are interpreted to
represent one byte string if there are no spaces between delimiters (", ', |).
Below are some examples of valid byte strings.

"hello"
|68656c6c6f| ...("hello" as a byte string)
"null TERMINATED"_n
|A17FE3|_t"abc"_t"def"
'quotes"""""'_l"singlequotes''''''"
_e"[0m" ...(example of a ANSI escape code)

Instructions -------------------------------------------------------------------

Instructions represent operations to be performed by the hardware. Instructions
are represented by UcL syntax. Normally, UcL syntax would be interpreted as a
continuing nested component of a program. To use UcL syntax in abstract, the 
syntax must be bounded by backquotes, "`". The purpose of this is to handle 
an arbitrary block of syntax as a single unit of data. The validity of the 
syntax contained in the backquotes is only checked when it is interpreted as 
syntax.

Instructions can also be represented directly using a lambda. This method is
described in the section, Lambdas.

Generic Data -------------------------------------------------------------------

The presence and absence of data can be specified in abstract using the 
identifiers, "t", signifying that data exists at a location, or "nil", 
signifying that data does not exist at a location. These abstractions can also
be used for boolean operations or a union data structure where the type of the
referenced data is ambiguous.

Data Structures ----------------------------------------------------------------

Along with the fundamental natural data types, there exists three fundamental 
data structures. They are the array, the record, and the list. These three data 
structures represent the existence and positioning of data in a program.

Array --------------------------------------------------------------------------

An array is an indexed collection of elements, each identified by an index. 
Arrays can represent both linear organization or matricies. Arrays hold a series
of elements of a single data type.

Record -------------------------------------------------------------------------

A record (also known as a structure or struct) is a collection of fields with a
fixed number and sequence. Records are unique from arrays because they can 
contain elements with different types and the elements inside are accessed using
an identifier rather than a numerical index.

Lists --------------------------------------------------------------------------

The most important data structure in UcL is the list. Lists are how UcL itself 
(see Syntax) is represented. Lists exist as a series of nodes with each node 
containing a piece of data and one or more references to adjacent nodes in the 
list.

Lists are better suited for dynamic structures where the ordering and length of
the list might change. However, lists are less optimal for random access due to
the fact that knowing the position of an element is dependent on knowing the
position of adjacent nodes.

Variables ----------------------------------------------------------------------

Variables contain a reference to the location of data. Data may be stored in a 
program by associating it with a variable. In UcL, variables may contain the
location of both Data and Data Structures.

Variable identifiers consist of non-control, non-whitespace characters. The
backquote character is reserved from identifiers because every character
following the first backquote is blindly taken in as instruction data. Variable
identifiers cannot contain sequences of characters that would otherwise 
represent data. Refer to the syntax examples in the previous sections, Numbers,
Byte Strings, and Instructions for examples of how NOT to name a variable 
identifier. 

Variable identifiers are case sensitive. 

Below are some examples of acceptable variable identifiers.

6yzz%
variable
x
y
binary
7.8FF=
+345$
*E*
\f\
5$#G
....
a"ifh"
afafffff

To avoid ambiguity between identifiers and data, the rules in the previous 
sections, Numbers and Byte Strings should NOT be followed. This is the most
direct way to avoid undefined behavior in a program. General rules of thumb to 
avoid ambiguity between variable identifiers and representations of data are 
listed below.

Identifiers shouldn't start with a pound sign, "#". If they do, make sure to 
include at least one character that is not 0-9, a-f, A-F, "^", or ".".

Identifiers shouldn't ever begin with a single quote, a double quote, a pipe, or
an underscore. These represent the beginning of a byte string. If an identifier
does begin with a byte string prefix, the identifier should never end with the
corresponding ending suffix.

If an identifier begins with an underscore character, it should be followed by
at least two characters, or a character that is not a neumonic (see Byte
Strings).

If an identifier looks like it could be interpreted as data, it's usually best
to use a different identifier to avoid inciting undefined behavior in the 
program from identifiers being interpreted as data.

Syntax -------------------------------------------------------------------------

UcL syntax consists of all visible characters and whitespace in the standard 
ASCII table. 

UcL syntax is constructed using S-expressions, also referred to as "lists". An 
S-expression is a binary tree structure used to represent nested list data. A 
single node in an S-expression is called an "Atom". An Atom consists of an 
ordered pair of references. A reference can contain the location of data, or 
the location of the root Atom of another S-expression. Being able to reference 
another S-expression facilitates the recursive nesting behavior of 
S-expressions.

In an S-expression with multiple Atoms, the first reference of each Atom 
represents the location of a piece of data. The second reference represents the
location of the next Atom in the expression. In this way, Atoms are used to
construct the linked list structure that is so well knowm in Lisp. Below is an 
example of a nested pair of S-expressions.

root (data \)
            `(data  \)
                     `(/  \)
                      /    `(Empty)
                     /
                    root (data \)
                                `(data \)
                                        `(Empty)

In UcL, an S-expression is represented using a closed pair of parentheses, "()".
Individual Atoms in the expression are represented by syntax expressions
separated by spaces. Nested parentheses do not need to be separate by spaces. 

If the first atom of an expression is a variable identifier or a lambda, then
the expression is interpreted as an invokation of the lambda or the function
referenced by the variable and all following elements are
used as parameters to the function.

Below are some examples of acceptable syntax.

(xvds 1.25)
(a b c d)
(f 5 9 "hello")
(t (t (t (t nil))))
(x b ("hello") (123))

Atoms with a reference to a single location can be abbreviated without using
parentheses. Below are some examples.

(1 nil) = 1
("string" nil) = "string"
(identifier nil) = identifier

Lambdas ------------------------------------------------------------------------

In the section, Instructions, the backquote character was used to enter 
instructions into the environment as an abstracted unit. Direct instructions 
that are used by the program are represented by the lambda. The name lambda
comes from Lambda Calculus which is a system for expressing computation. A
lambda by itself represents an anonymous function. It can act on data where it
is directly declared, but it is not stored in the environment. Lambdas can be
stored as callable functions by associating them with a variable.

A lambda consists of a single list that can optionally contain other
nested lists. The first element of a lambda expression is always the 
character "l". The element following the lambda declaration is a list of
the parameters that the lambda might use. Any following lists represent 
the operations the lambda performs.

Lambda Parameters --------------------------------------------------------------

Lambdas can have any number of parameters.
