The Uncommon Lisp Language Standard  -------------------------------------------
June 2020
(C)opyright Daniel (Robin) Smith

Introduction -------------------------------------------------------------------

This standard describes the qualities of a modern dynamic Lisp programming 
language, "Uncommon Lisp", and the dynamic language environment used to 
create programs in this language.

UcL is described using plain english. Like all Lisp languages, UcL is capable of
self-description, but for the sake of clarity, UcL is described in external
concepts.

Design Philosophy --------------------------------------------------------------

Umcommon Lisp, or "UcL", is a Lisp language with a modern design. Many of the 
features that made Lisp famous were designed in the past for a drastically
different environment. UcL reimagines these famous qualities in a way that's 
comdusive to modern programming. Uncommon Lisp can be considered a consolidation
of the philosophies presented by modern Lisp languages like Common Lisp, 
Clojure, and Scheme.

Uncommon Lisp has only a few design principals:
1. Prioritize emergent syntax.
2. Be reasonably compact
3. Allow future-proofing

Emergent syntax means that there should be many ways to implement an algorithm,
using the same base set of operations. Take mathematical operations for example.
There are five basic symbols that can be combined in any order to achieve a
specific algorithm. It's easier to add three addends using two additions than to
invent a new symbol specifically for adding three numbers. In that same sense, 
Uncommon Lisp shall not implement an abstract operation as a component of the 
language unless it cannot be represented with already existing syntax. This 
avoids the redundancy that often occurs in Common Lisp syntax.

Parallel to the first principal, Uncommon Lisp will be a small language. This is
not the same sense of small as Scheme, where any usefulness to the language must
be hand implemented by the users. This is why the term "compact" is used instead
of "small". Scheme is small and it lacks so many basic features that it's 
impossible to use except when implementing a higer level, more feature-full
language. Uncommon Lisp is full-featured without having an overwhelming amount 
of syntax.

The third principal is likely the most important. Lisp as a language is not
future proof. It was designed when general purpose hardware wasn't a concept, 
and died when the PC was popularized. Modern Lisp languages have no access to 
the underlying system because they were left behind when C became the system
language of choice. Uncommon Lisp implements two measures to avoid obsoletion,
it implements a means of interacting with native system libraries, and it
allows extension to implement access to any future manner of resource without
breaking the syntax.

Language Overview --------------------------------------------------------------

UcL is a multi-paradigm dynamic language with object orientation and a weak type
system with dynamic typing. UcL syntax uses traditional Lisp parenthesized 
prefix notation to represent operations. UcL can be statically compiled, but
like Lisp, it contains many reflective features suited for use in a dynamic 
environment.

Data ---------------------------------------------------------------------------

Natural information types are the underlying data types that support the UcL 
object typing system. Natural information exists as numbers, strings, or 
instructions. These three natural types are how information is introduced into
the language environment by the programmer. These three types are how 
information can be represented both internally in computers and externally
in human communication.

Numbers ------------------------------------------------------------------------

Numbers can be any rational value. They can be described using decimal or 
scientific notation. UcL additionally supports the numerical bases 2, 10, 16 
and 256. Numbers are represented by the ASCII characters 0-9 and for hexadecimal
values, A-F as well. A radix point is represented by the dot character, ".". A 
single numerical place for bases 2, 10, and 16 is represented by a single 
character. For base 256, a single place is represented by a pair of hexadecimal
symbols and is end-bounded by a comma, "," unless a radix point is present. 

Positive and negative values are denoted using a sign prefix which is either a
plus or minus character, "+" "-" respectively. If a sign prefix is not present,
the represented numerical value is assumed to be positive.

Decimal Notation ---------------------------------------------------------------

In UcL, decimal notation is represented by an optional sign prefix, followed by
a number of numeric places followed by an optional radix point, ".", followed by
an optional number of numeric places. Each numeric place value is represented by
numerals 0-9 for bases 2 and 10 and 0-F for bases 16 and 256. 

In base two, only ones and zeros are accepted.
In a base 10 number, only 0-9 is accepted. 
In a hexadecimal number, only 0-F is accepted. 
In a base 256 number, only 0-F are accepted. 

Decimal notation without a sign prefix is assumed to represent a positive
number.

Below are some examples of decimal notation in UcL.
-7
4.5
10010
+4FC
-7F,5F.3A,1D

Scientific Notation ------------------------------------------------------------

In UcL, scientific notation is represented by an optional sign prefix, followed 
by a numerical place, followed by a radix point, followed by a number of 
numerical places, followed by an exponent symbol, "^", followed by an optional 
sign prefix, followed by a number of numerical places. The places after the 
exponent symbol represent a power of the base number of the numerical base of 
the first number.

Below are some examples of Scientific Notation in UcL.

+3.05^4
-100101^11101
FF^-A4
74,FF^1A,04

Determining Numerical Representations ------------------------------------------

The type of numerical representation is determined in the following way. 
If a number does not have an exponent symbol "^", then it uses decimal notation, 
otherwise it uses scientific notation. 
If a number contains a radix point, it represents a rational value. 
If a number contains a comma, it represents a base 256 value.
If a number contains alphabetical characters, it represents a hexadecimal value.
If a number contains only numerical characters, it represents a decimal value.
If a number contains only the "1" and "0" characters, it represents a binary
value.
If a number begins with a "+" or "_" character, it is signed positive or 
negative. 
If an exponent symbol is followed directly by a "+" or "-" character, the 
exponential power is signed positive or negative.

Byte Strings -------------------------------------------------------------------

A byte string consists of a contiguous series of single byte values. Byte
strings can represent both raw data and ASCII, A byte string is represented by
an ASCII character string, or hexadecimal values.

A character string is represented by ASCII characters surrounded by double or 
single quotes. Double or single quotations have the same meaning, but if a 
string contains a single quote character, it must be surrounded by double quotes
and single quotes if a double quote character is used in the string.

A byte string is represented using two digit hexadecimal values surrounded by
pipe symbols, "|". Because each byte is represented by a hexadecimal pair, a
byte string must always contain an even number of characters.

Control characters and invisible characters are represented by an underscore
prefix, followed by a single character abbrrciation. Below is a list of 
abbreviations for different ascii values. 

t - horizontal tab
l - line feed
r - carriage return
b - backspace
d - delete

c - End Of Text (^C)
d - End Of Transmission (EOF) (^D)
n - NULL (ASCII 0)

Constructing Byte Strings ------------------------------------------------------

Byte strings can be constructed using arbitrary combinations of the syntax
above. Strings of bytes, characters, and control characters can be combined to
represent a single contiguous byte string. Multiple strings are interpreted to
represent one byte string if there are no spaces between delimiters (", ', |).
Below are some examples of valid byte strings.

"hello"
|68656c6c6f| ...("hello" as a byte string)
"null TERMINATED"_n
|A17FE3|_t"abc"_t"def"
'quotes"""""'_l"singlequotes''''''"

Instructions -------------------------------------------------------------------

Instructions represent operations to be performed by the hardware. Instructions
are represented by UcL syntax.

Data Structures ----------------------------------------------------------------

Along with the fundamental natural data types, there exists two fundamental 
data structures. They are the array and the record. These two data structures
represent the existence and positioning of data in a program. The third data
structure is the List. It is a higher abstraction level than arrays and records
as it can contain arrays and records.

Array --------------------------------------------------------------------------

An array is an indexed collection of elements, each identified by an index. 
Arrays can represent both linear organization or matricies. Arrays hold a series
of elements of a single data type.

Record -------------------------------------------------------------------------

A record (also known as a structure or struct) is a collection of fields with a
fixed number and sequence. Records are unique from arrays because they can 
contain elements with different types and the elements inside are accessed using
an identifier rather than a numerical index.

Lists --------------------------------------------------------------------------

The most important data structure in UcL is the list. Lists are how UcL itself 
(see Syntax) is represented. Lists exist as a series of nodes with each node 
containing a piece of data and one or more references to adjacent nodes in the 
list.

Lists are better suited for dynamic structures where the ordering and length of
the list might change. However, lists are less optimal for random access due to
the fact that knowing the position of an element is dependent on knowing the
position of adjacent nodes.


Syntax -------------------------------------------------------------------------

UcL syntax consists of all visible characters including whitespace in the 
standard ASCII table. 

UcL syntax is constructed using S-expressions. An S-expression is a binary tree
structure used to represent nested list data. A single node in an S-expression
is called an "Atom". An Atom consists of an ordered pair of references. A 
reference can contain the location of data, or the location of the root Atom of
another S-expression. Being able to reference another S-expression facilitates
the recursive nesting behavior of S-expressions.

In an S-expression with multiple Atoms, the first reference of each Atom 
represents the location of a piece of data. The second reference represents the
location of the next Atom in the expression. In this way, Atoms are used to
construct the linked list structure that is so well knowm in Lisp. Below is an 
example of a nested pair of S-expressions.

root (data \)
            `(data  \)
                     `(/  \)
                      /    `(Empty)
                     /
                    root (data \)
                                `(data \)
                                        `(Empty)

In UcL, an S-expression is represented using a closed pair of parentheses, "()".
Individual Atoms in the expression are represented by syntax expressions
separated by spaces.

Objects ------------------------------------------------------------------------
